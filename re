r перед паттерном - позволяет не ставить экранирование, \ вместо \\

-------------------------

Найти все совпадения полные с шаблоном (без условий) и вернуть из списком.

text = "еда, беда, победа"
match = re.findall(r"еда", text)
print(match) --> [еда, еда, еда]

-------------------------

Специальные символы: \ . ^ $ ? + * {} [] () | - просто так нельзя записать, они могут быть как частью шаблона (буквой), 
так и служебными элементом языка re. Чтобы искать их как буквы - экранируем

-------------------------

Символьный класс - еда, еду, Еда, Еду (разница в регисте и окончании)

Ищем все варианты, что можно собрать из скобок
text = "Еда, беду, победа"
match = re.findall(r"[еE]д[ау]", text)  - в [] варианты ИЛИ
print(match) --> [Еда, еду, еда]

Ищем вхождение любой цифры, одной! Один символьный класс - один готовый вариант
text = "Еда, беду, 6, победа"
match = re.findall(r"[0123456789]", text)  - в [] варианты ИЛИ
print(match) --> ['6']

text = "Еда, беду, 66, победа"
match = re.findall(r"[0123456789]", text)  - в [] варианты ИЛИ
print(match) --> ['6', '6']

Две цифры подряд - два класса подряд
text = "Еда, беду, 6, 66, победа"
match = re.findall(r"[0123456789][0123456789]", text)  - одну уже не найдет, только две подряд
print(match) --> ['66']

Чтобы не писать [0123456789] можно взять интервал [0-9], обозначает то же самое

Найти со дефисом впереди
text = "Еда, беду, -6, 66, победа"
match = re.findall(r"[-0-9][0-9]", text)  - первый [] значит или цифру, или -, второй только цифру
print(match) --> ['-6','66']

Найти все, кроме цифры (инвертирование ^)
text = "Еда, -6, 66"
match = re.findall(r"[^0-9]", text) 
print(match) --> ['E', 'д', 'а', ',', ' ', '-'] - буквы, пунктуация, пробелы

Найти все строчные буквы
text = "Еда, -6"
match = re.findall(r"[а-я]", text) 
print(match) --> ['д', 'а', ',', ' ', '-','6'] - строчные буквы, пунктуация, пробелы

match = re.findall(r"[а-яА-Я0-9]", text)  - интервалы без пробелов, будет искать прописные, строчные, цифры
                                            порядок интервалов не важен, искать будет во всех
                                            
В символьном классе спецсимволы воспринимаются как обычные, без системных функций.
Кроме обратного слеша \ - он сохраняет функциональность и поэтому можно вставить
знак табуляции (\t) или перенос строки (\n) в символьный класс

Символьные классы очень популярны, поэтому у них есть короткие псевдонимы:
.  - любой символ, кроме \n (исключение, только вне [])
\d - любая цифра в Юникоде, либо [0-9]
\D - любая Нецифра, либо [^0-9]
\s - любой пробельный символ (пробел, перенос строки, табуляция, перенос каретки ...)
\S - любой НЕпробельный символ
\w - любой символ слова, либо [a-zA-Z0-9]
\W - любой НЕсимвол слова, либо [^a-zA-Z0-9]

Примеры:

text = "Еда, беду, -5 55"
match = re.findall(r"\w", text) - все одинарные цифры  --> ['5', '5', '5']
match = re.findall(r"\w", text) - все символы слова --> ['Е', 'д', 'а', 'б', 'е', 'д', 'у', '5', '5', '5']
match = re.findall(r"\W", text) - все Несимволы слова --> [',', ' ', ',', ' ', '-', ' ']

Есть возможность добавить флаг и поменять поведение, например
match = re.findall(r"\w", text, re.ASCII) - все РУССКИЕ символы слова --> ['5', '5', '5'] остались только цифры
